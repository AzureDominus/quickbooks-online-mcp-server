# MCP tool output normalization (mcporter / generated CLI)

Date: 2026-02-01

## Context

We use this MCP server via:

- `mcporter call QuickBooks.<tool> --output json`
- a bundled CLI generated by mcporter (`mcporter generate-cli --server QuickBooks ...`)

Both of these workflows work best when a tool returns **a single JSON payload**.

## Problem: “weird JSON” tool responses

Many tools were returning **multiple `content` entries** and/or mixing human-oriented text with JSON.

Common patterns:

1) **Human prefix + JSON block**

```ts
return {
  content: [
    { type: 'text', text: `Found ${n} purchases:` },
    { type: 'text', text: JSON.stringify(payload, null, 2) },
  ],
};
```

2) **One JSON object per line / per content chunk** (especially `search_*` tools)

```ts
return {
  content: [
    { type: 'text', text: `Found ${results.length} vendors:` },
    ...results.map((v) => ({ type: 'text', text: JSON.stringify(v) })),
  ],
};
```

Why this is a problem:

- `mcporter --output json` expects the tool output to be parseable as JSON.
- The generated CLI also relies on JSON-only output for predictable parsing.
- The multi-chunk format creates edge cases (e.g., quoting/backticks/escapes) and forces callers to implement bespoke parsing.

## Goal

Make tool outputs **machine-readable by default**:

- A tool success response should emit **exactly one** `content` text item.
- That text item should be a JSON string (from `JSON.stringify(...)`) with no extra prefix text.
- Count-only responses should return `{"count": <number>}`.

## Fix implemented

### 1) Normalize success outputs to a single JSON payload

Updated tools in `src/tools/*.tool.ts` to return:

```ts
return {
  content: [{ type: 'text' as const, text: JSON.stringify(payload) }],
};
```

### 2) Normalize count-only outputs

For tools that support count-only mode, return:

```ts
return {
  content: [{ type: 'text' as const, text: JSON.stringify({ count }) }],
};
```

### 3) Keep errors as plain strings (for now)

Most tools still return human-readable error strings like:

```ts
{ content: [{ type: 'text', text: `Error searching vendors: ${response.error}` }] }
```

This is deliberate for now (easy to read). If we want fully machine-readable errors later, we can standardize to:

```json
{"error": {"message": "..."}}
```

### Tools updated

The normalization pass covered (at minimum):

- `search_*`: vendors, purchases, customers, bills, bill payments, employees, items, estimates, invoices, accounts, tax codes
- `get_*` / `read_*`: customer, vendor, purchase, employee, estimate, journal entry, bill payment, tax code, invoice, item
- `get_attachments`
- `health_check`
- create/update/delete tools that previously returned multiple `content` items

## Verification

Examples that should now produce clean JSON:

```bash
mcporter call QuickBooks.search_vendors limit:3 --output json
mcporter call QuickBooks.search_tax_codes --output json
mcporter call QuickBooks.search_purchases desc:TxnDate limit:3 --output json
mcporter call QuickBooks.search_customers limit:3 --output json
mcporter call QuickBooks.health_check --output json
```

The bundled CLI should also work cleanly:

```bash
cd /home/timmy/claw-spaces/don
mcporter generate-cli --server QuickBooks --output ./generated/QuickBooks.ts --bundle ./bin/quickbooks
./bin/quickbooks -o json search-vendors --limit 3
```

## Known issue: `count:true` causes QBO query parse errors for some endpoints

Some endpoints error when `count:true` is supplied, e.g.:

```bash
mcporter call QuickBooks.search_invoices count:true --output json
mcporter call QuickBooks.search_items count:true --output json
```

Observed error (example):

```
Error parsing query
QueryParserError: Encountered " \"count\" \"count \"\" at line 1, column 29.
Was expecting one of:
  "(" ...
  <NOT> ...
  <IDENTIFIER> ...
  <ID> ...
  <STRING> ...
(code: 4000)
```

Notes:

- This appears to be a limitation/bug in how `node-quickbooks` builds queries when a `count` option is passed.
- Internally, some handlers run criteria through `buildQuickbooksSearchCriteria(...)`, which may transform `count:true` into a criteria entry that ends up in the final QBO query string.

### Workarounds

- Do not use `count:true` for affected tools.
- If a total count is needed, implement one of:
  - Use `QueryResponse.totalCount` when the QBO endpoint provides it.
  - Fetch results with a large `limit` (or `fetchAll:true`) and compute `count = results.length` (can be slow).

### Next step (if we want to fix it properly)

- Determine which QBO entities/endpoints support server-side counts.
- Adjust criteria building so `count` is not injected as a query token for endpoints that don’t support it.
- Alternatively: remove `count` from tool schemas for the endpoints where it is known to break.
