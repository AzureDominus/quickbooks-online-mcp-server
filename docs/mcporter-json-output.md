# MCP tool output normalization (mcporter / generated CLI)

Date: 2026-02-01

---

## IMPORTANT: Build Requirement

> **mcporter and the generated CLI run `dist/index.js`, and `dist/` is gitignored.**
>
> After switching branches or pulling new changes, you **MUST** either:
>
> 1. Run `npm run build` to compile TypeScript to `dist/`, **OR**
> 2. Use the auto-build wrapper script: `bin/quickbooks-mcp` (if available)
>
> Without this step, you will be running stale code from a previous build!

---

## Context

We use this MCP server via:

- `mcporter call QuickBooks.<tool> --output json`
- a bundled CLI generated by mcporter (`mcporter generate-cli --server QuickBooks ...`)

Both of these workflows work best when a tool returns **a single JSON payload**.

## Problem: “weird JSON” tool responses

Many tools were returning **multiple `content` entries** and/or mixing human-oriented text with JSON.

Common patterns:

1. **Human prefix + JSON block**

```ts
return {
  content: [
    { type: 'text', text: `Found ${n} purchases:` },
    { type: 'text', text: JSON.stringify(payload, null, 2) },
  ],
};
```

2. **One JSON object per line / per content chunk** (especially `search_*` tools)

```ts
return {
  content: [
    { type: 'text', text: `Found ${results.length} vendors:` },
    ...results.map((v) => ({ type: 'text', text: JSON.stringify(v) })),
  ],
};
```

Why this is a problem:

- `mcporter --output json` expects the tool output to be parseable as JSON.
- The generated CLI also relies on JSON-only output for predictable parsing.
- The multi-chunk format creates edge cases (e.g., quoting/backticks/escapes) and forces callers to implement bespoke parsing.

## Goal

Make tool outputs **machine-readable by default**:

- A tool success response should emit **exactly one** `content` text item.
- That text item should be a JSON string (from `JSON.stringify(...)`) with no extra prefix text.
- Count-only responses should return `{"count": <number>}`.

## Fix implemented

### 1) Normalize success outputs to a single JSON payload

Updated tools in `src/tools/*.tool.ts` to return:

```ts
return {
  content: [{ type: 'text' as const, text: JSON.stringify(payload) }],
};
```

### 2) Normalize count-only outputs

For tools that support count-only mode, return:

```ts
return {
  content: [{ type: 'text' as const, text: JSON.stringify({ count }) }],
};
```

### 3) Keep errors as plain strings (for now)

Most tools still return human-readable error strings like:

```ts
{
  content: [{ type: 'text', text: `Error searching vendors: ${response.error}` }];
}
```

This is deliberate for now (easy to read). If we want fully machine-readable errors later, we can standardize to:

```json
{ "error": { "message": "..." } }
```

### 4) Create tools: optional envelope format (non-breaking)

By default, `create_*` tools return the created entity directly.

If you want a consistent wrapper across **all** create tools, pass `responseFormat: "envelope"`.

Envelope shape:

```json
{
  "entityType": "Vendor",
  "entity": { /* created entity */ },
  "meta": {
    "id": "123",
    "wasIdempotent": false
  }
}
```

This also normalizes idempotency-hit responses (which otherwise return `{ "Id": "...", "wasIdempotent": true }`).

### Tools updated

The normalization pass covered (at minimum):

- `search_*`: vendors, purchases, customers, bills, bill payments, employees, items, estimates, invoices, accounts, tax codes
- `get_*` / `read_*`: customer, vendor, purchase, employee, estimate, journal entry, bill payment, tax code, invoice, item
- `get_attachments`
- `health_check`
- create/update/delete tools that previously returned multiple `content` items

## Verification

### Step 1: Build the project

```bash
npm run build
```

### Step 2: Run tests

```bash
npm test
```

### Step 3: Verify JSON output is parseable by jq

Examples that should produce clean JSON:

> Note: `mcporter --output json` has an upstream edge case: on **input validation errors** it may emit **non-JSON** output and still exit **0**.
> For scripts/CI, enable `pipefail` + use `jq -e`, or wrap commands with `bin/strict-json` so failures reliably produce a non-zero exit code.
> See also: [upstream-mcporter-json-error.md](upstream-mcporter-json-error.md).

```bash
set -o pipefail
bin/strict-json mcporter call QuickBooks.search_customers limit:3 --output json | jq -e .
```

```bash
# All outputs should be parseable by jq
mcporter call QuickBooks.search_vendors limit:3 --output json | jq .
mcporter call QuickBooks.search_tax_codes --output json | jq .
mcporter call QuickBooks.search_purchases desc:TxnDate limit:3 --output json | jq .
mcporter call QuickBooks.search_customers limit:3 --output json | jq .
mcporter call QuickBooks.health_check --output json | jq .
```

### Step 4: Verify the bundled CLI (optional)

```bash
cd /home/timmy/claw-spaces/don
mcporter generate-cli --server QuickBooks --output ./generated/QuickBooks.ts --bundle ./bin/quickbooks
./bin/quickbooks -o json search-vendors --limit 3 | jq .
```

## Fixed: `count:true` now works for all search endpoints

Previously, `count:true` caused QBO query parse errors for some endpoints (e.g., `search_invoices`, `search_items`). This has been fixed.

### Root cause

The issue was in how `buildQuickbooksSearchCriteria` passed the count option to `node-quickbooks`. The library looks for a top-level `count: true` property on objects in the criteria array, but we were adding `{field: 'count', value: true}` instead. This caused `node-quickbooks` to:

1. Not recognize the count mode (no `select count(*) from` transformation)
2. Include `count = true` in the SQL WHERE clause via `criteriaToString`, which is invalid SQL

### Fix

1. **Criteria builder** (`src/helpers/build-quickbooks-search-criteria.ts`):
   - Now adds `{count: true}` at index 0 of the criteria array instead of `{field: 'count', value: true}`
   - Placing at index 0 works around a splice bug in `node-quickbooks` (line 2517: `criteria.splice(i, i + 1)` removes `i + 1` elements instead of 1)

2. **New helper functions**:
   - `isCountQuery(criteria)`: Checks if a criteria array/object has count mode enabled
   - `extractQueryResult(queryResponse, entityKey, isCount)`: Extracts entity array or `totalCount` from `QueryResponse`

3. **All search handlers** updated to:
   - Detect count mode using `isCountQuery`
   - Return `totalCount` as a number when in count mode
   - Return entity array otherwise

### Usage

Count mode now works consistently across all search endpoints:

```bash
mcporter call QuickBooks.search_invoices count:true --output json
# Returns: {"count": 42}

mcporter call QuickBooks.search_items count:true --output json
# Returns: {"count": 15}

mcporter call QuickBooks.search_customers count:true --output json
# Returns: {"count": 100}
```
